[{"name":"ValuableFile","comment":"\n\n\n# ValuableFiles\n\n@docs ValuableFile, decoder, encode, toFile\n\n\n# Extract Content\n\n@docs toString, toBytes, toUrl\n\n\n# Read Metadata\n\n@docs name, mime, size, lastModified\n\n","unions":[{"name":"ValuableFile","comment":" Represents a file. From there you can read the content, check the\nmetadata, send it over a port, etc.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"decoder","comment":" Decode `File` values. For example, if you want to create a drag-and-drop\nfile uploader, you can listen for `drop` events with a decoder like this:\n\n    import Json.Decode exposing (Decoder, field, list)\n    import ValuableFile exposing (ValuableFile)\n\n    files : Decode.Decoder (List ValuableFile)\n    files =\n        field \"dataTransfer\" (field \"files\" (list ValuableFile.decoder))\n\nOnce you have the files, you can use functions like\n[`ValuableFile.toString`](#toString) to process the content.\nOr you can send the file along to someone else with the\n[`elm/http`](/packages/elm/http/latest) package.\n\n","type":"Json.Decode.Decoder ValuableFile.ValuableFile"},{"name":"encode","comment":" Encode `File` values. This is useful to send them through a port:\n\n    import ValuableFile\n\n    port sendFile : Value -> msg\n\nthen in an update function:\n\n    case msg of\n        ValuableFileSelected (Ok file) ->\n            ( model, sendFile (ValuableFile.encode file) )\n\n","type":"ValuableFile.ValuableFile -> Json.Decode.Value"},{"name":"lastModified","comment":" Get the time the file was last modified.\n\n    ValuableFile.lastModified file1 -- 1536872423\n\n    ValuableFile.lastModified file2 -- 860581394\n\n    ValuableFile.lastModified file3 -- 1340375405\n\nLearn more about how time is represented by reading through the\n[`elm/time`](/packages/elm/time/latest) package!\n\n","type":"ValuableFile.ValuableFile -> Time.Posix"},{"name":"mime","comment":" Get the MIME type of a file.\n\n    ValuableFile.mime file1 == \"text/markdown\"\n\n    ValuableFile.mime file2 == \"image/gif\"\n\n    ValuableFile.mime file3 == \"application/zip\"\n\n","type":"ValuableFile.ValuableFile -> String.String"},{"name":"name","comment":" Get the name of a file.\n\n    ValuableFile.name file1 == \"README.md\"\n\n    ValuableFile.name file2 == \"math.gif\"\n\n    ValuableFile.name file3 == \"archive.zip\"\n\n","type":"ValuableFile.ValuableFile -> String.String"},{"name":"size","comment":" Get the size of the file in bytes.\n\n    ValuableFile.size file1 == 395\n\n    ValuableFile.size file2 == 65813\n\n    ValuableFile.size file3 == 81481\n\n","type":"ValuableFile.ValuableFile -> Basics.Int"},{"name":"toBytes","comment":" Extract the content of a `File` as `Bytes`. So if you have an `archive.zip`\nfile you could read the content like this:\n\n    import Bytes exposing (Bytes)\n    import Task\n    import ValuableFile exposing (ValuableFile)\n\n    type Msg\n        = ZipLoaded Bytes\n\n    read : ValuableFile -> Cmd Msg\n    read file =\n        Task.perform ZipLoaded (ValuableFile.toBytes file)\n\nFrom here you can use the [`elm/bytes`](/packages/elm/bytes/latest) package to\nwork with the bytes and turn them into whatever you want.\n\n","type":"ValuableFile.ValuableFile -> Task.Task x Bytes.Bytes"},{"name":"toFile","comment":" Convert to a standard [elm/file](/packages/elm/file/latest) File, for example to send\nit over [elm/http](/packages/elm/http/latest).\n\n    import Http\n\n    Http.multipartBody\n        [ stringPart \"product\" \"Ikea Bekant\"\n        , stringPart \"description\" \"Great desk for home office.\"\n        , filePart \"image[]\" (ValuableFile.toFile file1)\n        , filePart \"image[]\" (ValuableFile.toFile file2)\n        , filePart \"image[]\" (ValuableFile.toFile file3)\n        ]\n\n","type":"ValuableFile.ValuableFile -> File.File"},{"name":"toString","comment":" Extract the content of a `File` as a `String`. So if you have a `notes.md`\nfile you could read the content like this:\n\n    import Task\n    import ValuableFile exposing (ValuableFile)\n\n    type Msg\n        = MarkdownLoaded String\n\n    read : ValuableFile -> Cmd Msg\n    read file =\n        Task.perform MarkdownLoaded (ValuableFile.toString file)\n\nReading the content is asynchronous because browsers want to avoid allocating\nthe file content into memory if possible. (E.g. if you are just sending files\nalong to a server with [`elm/http`](/packages/elm/http/latest) there is no\npoint having their content in memory!)\n\n","type":"ValuableFile.ValuableFile -> Task.Task x String.String"},{"name":"toUrl","comment":" The `File.toUrl` function will convert files into URLs like this:\n\n  - `data:*/*;base64,V2hvIGF0ZSBhbGwgdGhlIHBpZT8=`\n  - `data:*/*;base64,SXQgd2FzIG1lLCBXaWxleQ==`\n  - `data:*/*;base64,SGUgYXRlIGFsbCB0aGUgcGllcywgYm95IQ==`\n\nThis is using a [Base64](https://en.wikipedia.org/wiki/Base64) encoding to\nturn arbitrary binary data into ASCII characters that safely fit in strings.\n\nThis is primarily useful when you want to show images that were just uploaded\nbecause **an `<img>` tag expects its `src` attribute to be a URL.** So if you\nhave a website for selling furniture, using `File.toUrl` could make it easier\nto create a screen to preview and reorder images. This way people can make\nsure their old table looks great!\n\n","type":"ValuableFile.ValuableFile -> Task.Task x String.String"}],"binops":[]},{"name":"ValuableFile.Download","comment":" Commands for downloading files.\n\n**SECURITY NOTE:** Browsers require that all downloads are initiated by a user\nevent. So rather than allowing malicious sites to put files on your computer\nhowever they please, the user at least have to click a button first. As a\nresult, the following commands only work when they are triggered by some user\nevent.\n\n\n# Download\n\n@docs string, bytes, url\n\n","unions":[],"aliases":[],"values":[{"name":"bytes","comment":" Download some `Bytes` as a file. Maybe you are creating custom images,\nand you want a button to download them as PNG files. After using\n[`elm/bytes`][bytes] to generate the file content, you can download it like\nthis:\n\n    import Bytes exposing (Bytes)\n    import File.Download as Download\n\n    savePng : Bytes -> Cmd msg\n    savePng bytes =\n        Download.bytes \"frog.png\" \"image/png\" bytes\n\nSo the arguments are file name, MIME type, and then the file content. With the\nability to build any byte sequence you want with [`elm/bytes`][bytes], you can\ncreate `.zip` files, `.jpg` files, or whatever else you might need!\n\n[bytes]: /packages/elm/bytes/latest\n\n","type":"String.String -> String.String -> Bytes.Bytes -> Platform.Cmd.Cmd msg"},{"name":"string","comment":" Download a `String` as a file. Maybe you markdown editor in the browser,\nand you want to provide a button to download markdown files:\n\n    import File.Download as Download\n\n    save : String -> Cmd msg\n    save markdown =\n        Download.string \"draft.md\" \"text/markdown\" markdown\n\nSo the arguments are file name, MIME type, and then the file content. In this\ncase is is markdown, but it could be any string information.\n\n","type":"String.String -> String.String -> String.String -> Platform.Cmd.Cmd msg"},{"name":"url","comment":" Download a file from a URL on the same origin. So if you have a website\nat `https://example.com`, you could download a math GIF like this:\n\n    import File.Download as Download\n\n    downloadMathGif : Cmd msg\n    downloadMathGif =\n        Download.url \"https://example.com/math.gif\"\n\nThe downloaded file will use whatever name the server suggests. So if you want\na different name, have your server add a [`Content-Disposition`][cd] header like\n`Content-Disposition: attachment; filename=\"triangle.gif\"` when it serves the\nfile.\n\n**Warning:** The implementation uses `<a href=\"...\" download></a>` which has\ntwo important consequences:\n\n1.  **Cross-origin downloads are weird.** If you want a file from a different\n    domain (like `https://files.example.com` or `https://www.wikipedia.org`) this\n    function adds a `target=\"_blank\"`, opening the file in a new tab. Otherwise\n    the link would just take over the current page, replacing your website with a\n    GIF or whatever. To make cross-origin downloads work differently, you can (1)\n    make the request same-origin by sending it to your server and then having your\n    server fetch the file or (2) fetch the file with `elm/http` and then go through\n    `File.Download.bytes`.\n2.  **Same-origin downloads are weird in IE10 and IE11.** These browsers do not\n    support the `download` attribute, so you should always get the `target=\"_blank\"`\n    behavior where the URL opens in a new tab. Again, you can fetch the file with\n    `elm/http` and then use `File.Download.bytes` to get around this.\n\nThings are quite tricky here between the intentional security constraints and\nparticularities of browser implementations, so remember that you can always\nsend the URL out a `port` and do something even more custom in JavaScript!\n\n[cd]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition\n\n","type":"String.String -> Platform.Cmd.Cmd msg"}],"binops":[]},{"name":"ValuableFile.Input","comment":" File selectors.\n\n\n# Single File\n\n@docs file, onFile\n\n\n# Multiple Files\n\n@docs files, onFiles\n\n","unions":[],"aliases":[],"values":[{"name":"file","comment":" A single file input.\n\n    import Html exposing (Html)\n    import ValuableFile exposing (ValuableFile)\n    import ValuableFile.Input as Input\n\n    type Msg\n        = FileSelected File\n\n    view : Html msg\n    view =\n        Input.file\n            [ Input.onFile FileSelected\n            , Input.accept \"application/json\"\n            ]\n            []\n\nThis is an `Html.input` with `Html.Attributes.type_ \"file\"` preset\nfor convenience.\n\nTo style the input, hide it and use a label:\n\n    import Html.Attributes\n\n    view : Html msg\n    view =\n        div []\n            [ Input.file\n                [ Input.onFile FileSelected\n                , Attributes.id \"file-upload\"\n                , Attributes.style \"display\" \"none\"\n                ]\n                []\n            , Html.label\n                [ Attributes.for \"file-upload\"\n                , Attributes.style \"padding\" \"16px\"\n                , Attributes.style \"border\" \"1px solid grey\"\n                , Attributes.style \"cursor\" \"pointer\"\n                ]\n                [ Html.text \"Upload\"\n                ]\n            ]\n\n","type":"List.List (Html.Attribute msg) -> List.List (Html.Html msg) -> Html.Html msg"},{"name":"files","comment":" A multiple files input.\n\n    import Html exposing (Html)\n    import ValuableFile exposing (ValuableFile)\n    import ValuableFile.Input as Input\n\n    type Msg\n        = FilesSelected (List ValuableFile)\n\n    view : Html msg\n    view =\n        Input.files [ Input.onFiles FilesSelected ] []\n\nThis is an `Html.input` with `Html.Attributes.type_ \"file\"` and\n`Html.Attributes.multiple true` preset for convenience.\n\n","type":"List.List (Html.Attribute msg) -> List.List (Html.Html msg) -> Html.Html msg"},{"name":"onFile","comment":" Detect [change](https://developer.mozilla.org/en-US/docs/Web/Events/change)\nevents on file input. It will grab the value from\n`event.target.files` as a single file.\n","type":"(ValuableFile.ValuableFile -> msg) -> Html.Attribute msg"},{"name":"onFiles","comment":" Detect [change](https://developer.mozilla.org/en-US/docs/Web/Events/change)\nevents on multiple files input. It will grab the value from\n`event.target.files`.\n","type":"(List.List ValuableFile.ValuableFile -> msg) -> Html.Attribute msg"}],"binops":[]}]